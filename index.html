<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>isl->text->speech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <style>
    :root{
      --bg:#0f1220;      
      --card:#171a2b;     
      --accent:#7c5cff;   
      --text:#e9e9f1;     
      --muted:#a8a8c7;    
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
      background: radial-gradient(1200px 700px at 50% -10%, #1b1f35 0%, #0b0e1a 60%, #070912 100%);
      color:var(--text);
      min-height:100svh; display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .wrap{
      width:min(900px, 96vw);
    }
    header{
      text-align:center; margin-bottom:18px;
    }
    header h1{
      margin:0; font-size: clamp(20px, 4vw, 36px); letter-spacing:.5px; font-weight:800;
      text-transform: lowercase;
      color:var(--text);
    }
    header .subtitle{ color:var(--muted); font-size:14px; margin-top:6px }
    .card{
      background: linear-gradient(180deg, #15182a 0%, #0f1220 100%);
      border:1px solid #252847;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
      padding:18px;
    }

    
    .video-area{
      display:grid; place-items:center; padding:10px;
    }
    .video-shell{
      position:relative;
      width:min(720px, 92vw); aspect-ratio: 4/3;
      border-radius: 16px; overflow:hidden;
      background:#0d0f1b; border:1px solid #2b2f52;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    video{
      width:100%; height:100%; object-fit:cover;
      
      transform: scaleX(-1);
      display:block;
      filter: contrast(1.05) saturate(1.05);
    }
    canvas{
      position:absolute; inset:0; width:100%; height:100%;
      
      transform: scaleX(-1);
      pointer-events:none;
    }

    
    .result{
      text-align:center; margin-top:14px;
    }
    .word{
      font-weight:900;
      font-size: clamp(28px, 6vw, 64px);
      letter-spacing: .02em;
      color:var(--text);
      text-shadow: 0 4px 30px rgba(124,92,255,.35);
      min-height: 1.2em;
    }
    .hint{ color:var(--muted); font-size: 12px; margin-top: 6px }

    
    .controls{
      display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:16px;
    }
    button{
      appearance:none; border:none; cursor:pointer;
      font-weight:700; font-size:14px; letter-spacing:.2px;
      padding:12px 18px; border-radius: 14px;
      background: var(--accent);
      color:white;
      box-shadow: 0 10px 30px rgba(124,92,255,.45), inset 0 1px 0 rgba(255,255,255,.15);
      transition: transform .06s ease, box-shadow .2s ease, opacity .2s ease;
    }
    button.secondary{
      background:#262a4d; color:#e7e7ff; box-shadow: none; border:1px solid #343969;
    }
    button:active{ transform: translateY(1px) }
    button:disabled{ opacity:.5; cursor:not-allowed }

    footer{
      text-align:center; color:var(--muted); font-size:12px; margin-top:16px;
    }

    
    @media (max-width:480px){
      .hint{ display:none }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>isl-&gt;text-&gt;speech</h1>
      <div class="subtitle">Thumbs Up = “yes”, Thumbs Down = “no”, Fist = “hello”</div>
    </header>

    <div class="card">
      <div class="video-area">
        <div class="video-shell">
          
          <video id="video" playsinline></video>
          
          <canvas id="overlay"></canvas>
        </div>
      </div>

     
      <div class="result">
        <div id="word" class="word"> </div>
        <div class="hint">Tip: keep one hand visible, centered, and hold each gesture steady for a brief moment.</div>
      </div>

      
      <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" class="secondary" disabled>Stop Camera</button>
      </div>
    </div>

    <footer>
      Built with MediaPipe Hands + Web Speech (SpeechSynthesis) API. Plain HTML, CSS &amp; JavaScript.
    </footer>
  </div>

  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    

    
    const videoEl = document.getElementById('video');
    const canvasEl = document.getElementById('overlay');
    const canvasCtx = canvasEl.getContext('2d');
    const wordEl = document.getElementById('word');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');

    
    let camera = null;

    
    let mediaStream = null;

   
    const STABLE_FRAMES = 5; 
    let lastGesture = null;  
    let frameBuffer = [];    

    
    function speak(text){
      if(!('speechSynthesis' in window)) return; 
      
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1; u.pitch = 1; u.lang = 'en-IN';
      window.speechSynthesis.speak(u);
    }

    
    function resizeCanvasToVideo(){
      const rect = videoEl.getBoundingClientRect();
      canvasEl.width  = rect.width  * devicePixelRatio;
      canvasEl.height = rect.height * devicePixelRatio;
      canvasEl.style.width  = rect.width + 'px';
      canvasEl.style.height = rect.height + 'px';
    }
    window.addEventListener('resize', resizeCanvasToVideo);

   

    
    function dist(a, b){
      const dx = a.x - b.x, dy = a.y - b.y, dz = (a.z||0) - (b.z||0);
      return Math.hypot(dx, dy, dz);
    }

    
    function isFingerCurled(landmarks, tipIdx, pipIdx, threshold = 0.02){
      const tip = landmarks[tipIdx];
      const pip = landmarks[pipIdx];
      return (tip.y - pip.y) > threshold; 
    }

    
    function fourFingersCurled(landmarks){
      const curled =
        isFingerCurled(landmarks, 8, 6)  && 
        isFingerCurled(landmarks,12,10) && 
        isFingerCurled(landmarks,16,14) && 
        isFingerCurled(landmarks,20,18);   
      return curled;
    }

    
    function thumbDirection(landmarks){
      
      const tip = landmarks[4];
      const mcp = landmarks[2];
      const ip  = landmarks[3];
      const avgJointY = (mcp.y + ip.y)/2;
      const delta = tip.y - avgJointY;
      if (delta < -0.03) return 'up';
      if (delta >  0.03) return 'down';
      return 'neutral';
    }

    
    function isFist(landmarks){
      if(!fourFingersCurled(landmarks)) return false;
      const wrist = landmarks[0];
      
      const tips = [4,8,12,16,20].map(i => landmarks[i]);
      const avgDist = tips.reduce((s,p)=>s+dist(p,wrist),0)/tips.length;
      return avgDist < 0.25; 
    }

    
    function classifyGesture(landmarks){
      if(!landmarks || landmarks.length < 21) return '';

      
      if (isFist(landmarks)) return 'hello';

      
      if (fourFingersCurled(landmarks)){
        const dir = thumbDirection(landmarks);
        if (dir === 'up')   return 'yes';
        if (dir === 'down') return 'no';
      }

      return '';
    }

    
    function drawLandmarks(results){
      
      canvasCtx.clearRect(0,0,canvasEl.width, canvasEl.height);

      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

      
      canvasCtx.save();
      canvasCtx.scale(devicePixelRatio, devicePixelRatio);

      for (const landmarks of results.multiHandLandmarks) {
        
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { lineWidth: 3 });
        
        drawLandmarks_(canvasCtx, landmarks, { radius: 3.5 });
      }
      canvasCtx.restore();
    }

    
    function handleStableGesture(label){
      if (!label){
        frameBuffer = [];
        return;
      }
      frameBuffer.push(label);
      if (frameBuffer.length > STABLE_FRAMES) frameBuffer.shift();

      
      const allSame = frameBuffer.length === STABLE_FRAMES && frameBuffer.every(v => v === frameBuffer[0]);
      if (allSame){
        const stable = frameBuffer[0];
        if (stable !== lastGesture){
          lastGesture = stable;
          wordEl.textContent = stable;
          speak(stable);
        }
      }
    }

    
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    
    hands.onResults((results) => {
      
      drawLandmarks(results);

      
      const landmarks = (results.multiHandLandmarks && results.multiHandLandmarks[0]) ? results.multiHandLandmarks[0] : null;
      const label = classifyGesture(landmarks);

      
      handleStableGesture(label);

      
      if (!label && lastGesture === null) {
        wordEl.textContent = '';
      }
    });

    async function startCamera(){
      try{
        
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width:{ideal: 960}, height:{ideal: 720} },
          audio: false
        });
        videoEl.srcObject = mediaStream;
        await videoEl.play();

       
        resizeCanvasToVideo();

        
        camera = new Camera(videoEl, {
          onFrame: async () => {
            await hands.send({ image: videoEl });
          },
          width: videoEl.videoWidth || 640,
          height: videoEl.videoHeight || 480
        });
        camera.start();

        startBtn.disabled = true;
        stopBtn.disabled  = false;
      }catch(err){
        console.error(err);
        alert('Could not access the camera. Please allow camera permissions and try again.');
      }
    }

    function stopCamera(){
      try{
        
        if (camera && camera.stop) camera.stop();

        
        if (mediaStream){
          mediaStream.getTracks().forEach(t => t.stop());
          mediaStream = null;
        }

       
        canvasCtx.clearRect(0,0,canvasEl.width, canvasEl.height);
        frameBuffer = [];
        lastGesture = null;
        wordEl.textContent = '';

        startBtn.disabled = false;
        stopBtn.disabled  = true;
      }catch(err){
        console.error(err);
      }
    }

    
    startBtn.addEventListener('click', startCamera);
    stopBtn .addEventListener('click', stopCamera);

    
    window.addEventListener('visibilitychange', () => {
      if (document.hidden && mediaStream) stopCamera();
    });
  </script>
</body>
</html>